<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Opensess-svn] r18 - trunk/openSess
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/opensess-svn/2005-March/index.html" >
   <LINK REL="made" HREF="mailto:opensess-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpensess-svn%5D%20r18%20-%20trunk/openSess&In-Reply-To=%3C200503201354.j2KDs7ci004692%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000012.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Opensess-svn] r18 - trunk/openSess</H1>
    <B>Andreas Wickner at BerliOS</B> 
    <A HREF="mailto:opensess-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpensess-svn%5D%20r18%20-%20trunk/openSess&In-Reply-To=%3C200503201354.j2KDs7ci004692%40sheep.berlios.de%3E"
       TITLE="[Opensess-svn] r18 - trunk/openSess">awickner at sheep.berlios.de
       </A><BR>
    <I>Sun Mar 20 14:54:07 CET 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000012.html">[Opensess-svn] r17 - branches/alternative-assign/openSess
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13">[ date ]</a>
              <a href="thread.html#13">[ thread ]</a>
              <a href="subject.html#13">[ subject ]</a>
              <a href="author.html#13">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: awickner
Date: 2005-03-20 14:54:06 +0100 (Sun, 20 Mar 2005)
New Revision: 18

Added:
   trunk/openSess/TaskMonitor.java
Removed:
   trunk/openSess/PTAlloc.java
Modified:
   trunk/openSess/Persons.java
   trunk/openSess/Roles.java
   trunk/openSess/Solution.java
   trunk/openSess/Solver.java
   trunk/openSess/SolverConstructor.java
   trunk/openSess/Topics.java
Log:
Some improvements to the software structure:
- public data members made private and made accessible by methods.
- Contents of PTAlloc moved to Solution or Solver. PTAlloc deleted.
- TaskMonitor factored out of Solver.

Deleted: trunk/openSess/PTAlloc.java
===================================================================
--- trunk/openSess/PTAlloc.java	2005-03-15 13:52:49 UTC (rev 17)
+++ trunk/openSess/PTAlloc.java	2005-03-20 13:54:06 UTC (rev 18)
@@ -1,585 +0,0 @@
-
-package openSess;
-import java.text.NumberFormat;
-import java.util.Arrays;
-import java.util.Random;
-
-/*
- * Copyright 2005 Gero Scholz, Andreas Wickner
- * 
- * Created:     2005-02-11 
- * Revision ID: $Id$
- * 
- * 2005-02-14/AW: Changes to decrease excessive memory allocation/deallocation.
- * 2005-02-22/GS: Algorithm bug fixes 
- * 
- * This file is part of OpenSess.
- * OpenSess is free software; you can redistribute it and/or modify it 
- * under the terms of the GNU General Public License as published by 
- * the Free Software Foundation; either version 2 of the License, or 
- * (at your option) any later version.
- *
- * OpenSess is distributed in the hope that it will be useful, but 
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
- * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
- * for more details.
- *
- * You should have received a copy of the GNU General Public License along 
- * with OpenSess; if not, write to the Free Software Foundation, Inc., 
- * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
- */
-
-/**
- * PTAlloc performs the assignment of roles to persons and topics.
- * A PTAlloc instance can be used to perform the calculation of several
- * solutions. The method init() is used to set up the PTAlloc for
- * a particular solution which is then calculated by calling
- * assignRoles(). If isValidSolution() returns true afterwards,
- * the solution can be retrieved via createSolution().
- * 
- * @author Gero Scholz
- */
-public class PTAlloc
-{
-  private Solver       solver;
-  private Persons      persons;
-  private Topics       topics;
-
-  private boolean      debug;
-  private int          dimSessions;
-  private int          groups[];
-  private int          assigned[][];
-  private int          bestAssignment[][];
-  private int          pref[][];
-  private int          topicRole[][];
-  private int          personRole[][];
-  private int          nAssignments;
-  private int          seqPersons[][];
-  private int          personSum[];
-  private double       meanDeviation, maxDeviation, stdDeviation;
-  private NumberFormat compactFormat;
-  private boolean      solved;
-
-  /**
-   * Return true if the PTAlloc currently holds a valid solution.
-   * 
-   * @return true if the solution is valid, false otherwise.
-   */
-	public boolean isValidSolution()
-	{
-	  return solved;
-	}
-	
-	/**
-	 * Calculates the target value of the current assignment.
-	 * 
-	 * @return the target value.
-	 */
-  protected int targetValue()
-  {
-		int pval[] = new int[solver.dimPersons];
-    int val = 0;
-
-    for (int p = 0; p &lt; solver.dimPersons; p++)
-    {
-      for (int t = 0; t &lt; solver.dimTopics; t++)
-        if (assigned[p][t] &gt; 0)
-          pval[p] += pref[p][t];
-
-      val += pval[p];
-    }
-    
-    double mean = (val * 1.0 / solver.dimPersons);
-    double dev = 0;
-    
-    for (int p = 0; p &lt; solver.dimPersons; p++)
-      dev += (mean - pval[p]) * (mean - pval[p]);
-
-    dev = Math.sqrt(dev / solver.dimPersons);
-    val += (solver.dimBalancing * dev);
-
-    return val;
-  }
-
-  /**
-   * Constructs a new PTAlloc.
-   * It creates the necessary arrays which are used in subsequent
-   * calculations. Each calculation must be set up by a call to init().
-   *  
-   * @param solver      the Solver object.
-   */
-  public PTAlloc(Solver solver)
-  {
-    debug            = false;
-    this.solver      = solver;
-    this.persons     = solver.getPersons();
-    this.topics      = solver.getTopics();
-    this.dimSessions = solver.getSessionNumber();
-    this.solved      = false;
-    assigned         = new int[solver.dimPersons][solver.dimTopics];
-    bestAssignment   = new int[solver.dimPersons][solver.dimTopics];
-    topicRole        = new int[solver.dimTopics][solver.getRoles().getNumber() + 1];
-    personRole       = new int[solver.dimPersons][solver.getRoles().getNumber()  + 1];
-    // seqPersons[][0] = person, seqPerson[][1]=minPrio
-    nAssignments     = solver.dimPersons * solver.dimTopics / dimSessions;
-    seqPersons       = new int[nAssignments + 1][2];
-    personSum        = new int[solver.dimPersons];
-    // Prepare a number formatter
-    compactFormat = NumberFormat.getInstance();
-    compactFormat.setMinimumFractionDigits(2);
-    compactFormat.setMaximumFractionDigits(2);
-    
-    // we calculate the preference for each person and topic under the
-    // assumption of the given grouping
-
-    pref = new int[solver.dimPersons][solver.dimTopics];
-
-    for (int p = 0; p &lt; solver.dimPersons; p++)
-      for (int t = 0; t &lt; solver.dimTopics; t++)
-      	// changed pref to prefInx -- GS - 2005-02-22
-        pref[p][t] = solver.getPersons().prefInx[p][t];
-    
-    if (debug)
-    {
-      System.out
-          .println(&quot;\nPersonen und Pr&#228;ferenzen bei gegebener Themengruppierung:&quot;);
-      System.out.println(&quot;\n&quot; + persons.emptyName() + &quot;:   &quot;
-                         + topics.toHeaderString(&quot;   &quot;));
-      for (int p = 0; p &lt; solver.dimPersons; p++)
-      {
-        System.out.print(persons.getName(p) + &quot;:&quot;);
-        for (int t = 0; t &lt; solver.dimTopics; t++)
-        {
-          String tmp = &quot;    &quot; + pref[p][t];
-          System.out.print(tmp.substring(tmp.length() - 4));
-        }
-        System.out.println();
-      }
-    }
-  }
-
-  /**
-   * Initialize a calculation by performing a first assignment 
-   * without specific roles.
-   * 
-   * @param groups  the group of topics to work on.
-   * @param tries   the maximum number of tries.
-   * @param seed    the seed for the random number generator.
-   */
-  public void init(int[] groups, int tries, long seed)
-  {
-    for (int person = 0;  person &lt; solver.dimPersons;  ++person)
-    {
-      Arrays.fill(assigned[person], 0);  
-      Arrays.fill(bestAssignment[person], 0);
-    }
-    
-    // we generate a legal assignment as a starting point;
-    this.groups = groups;
-    
-    for (int gr = 0; gr &lt; groups.length / dimSessions; gr++)
-      for (int p = 0; p &lt; solver.dimPersons; p++)
-      {
-        int seq = 0;
-        
-        for (int t = 0; t &lt; solver.dimTopics; t++)
-          if (groups[t] == gr)
-          {
-            if (p / (solver.dimPersons / dimSessions) == seq)
-              assigned[p][t] = 9;
-
-            ++seq;
-          }
-      }
-
-    int target = targetValue();
-
-    if (debug)
-    {
-      System.out.println(&quot;\n&quot; + persons.emptyName() + &quot;:  &quot;
-                         + topics.toHeaderString(&quot; &quot;));
-      System.out.println(this + &quot;target=&quot; + target);
-    }
-
-    // again we apply simulated annealing; we try to swap people
-    // between sessions of the same group
-
-    // simulated annealing; we look for better solutions and
-    // adopt them in most cases (80%) as a starting point for the next trial
-    // sometimes we accept worse solutions and temporarily lower the
-    // expectation level
-
-    int bestTargetTotal = Integer.MAX_VALUE, bestTarget = Integer.MAX_VALUE, lastTarget = target;
-    Random rand = new Random();
-    
-    if (seed != 0)
-      rand = new Random(seed);
-
-    for (int y = 0; y &lt; tries; y++)
-    {
-      // modify constellation, later restore possible
-      int p1 = 0, t1 = 0, p2 = 0, t2 = 0;
-      p1 = rand.nextInt(solver.dimPersons);
-      t1 = rand.nextInt(solver.dimTopics / dimSessions);
-      // look for a topic the selected person is assigned to
-      for (int t = 0; t &lt; solver.dimTopics; t++)
-        if (assigned[p1][t] &gt; 0)
-        {
-          if (t1 &lt;= 0)
-          {
-            t1 = t;
-            break;
-          }
-          
-          --t1;
-        }
-
-        // pick a member of another topic of the same session
-      int n = rand.nextInt(solver.dimPersons - solver.dimPersons / dimSessions);
-      
-      for (int t = 0; t &lt; solver.dimTopics; t++)
-        if (groups[t] == groups[t1] &amp;&amp; t1 != t)
-          for (int p = 0; p &lt; solver.dimPersons; p++)
-          {
-            if (assigned[p][t] &gt; 0 &amp;&amp; n &lt;= 0)
-            {
-              p2 = p;
-              t2 = t;
-              break;
-            }
-            
-            --n;
-          }
-      
-      assigned[p1][t1] = 0;
-      assigned[p1][t2] = 9;
-      assigned[p2][t1] = 9;
-      assigned[p2][t2] = 0;
-
-      // calculate target value
-      lastTarget = target;
-      target = targetValue();
-      // pref[p1][t1]-pref[p1][t2]+pref[p2][t2]-pref[p2][t1]);
-
-      if (debug)
-      {
-        System.out.println(&quot;\np1=&quot; + p1 + &quot; t1=&quot; + topics.getName(t1)
-                           + &quot;  /  p2=&quot; + p2 + &quot; t2=&quot; + topics.getName(t2));
-        System.out.println(this + &quot;target=&quot; + target + &quot;   (&quot; + bestTarget
-                           + &quot;)  (&quot; + bestTargetTotal + &quot;)&quot;);
-      }
-
-      if (target &lt; bestTargetTotal)
-      {
-        // check if solution is known already
-        boolean known = false;
-        
-        if (!known)
-        {
-          bestTargetTotal = target;
-          // store best result
-          for (int p = 0; p &lt; solver.dimPersons; p++)
-            for (int t = 0; t &lt; solver.dimTopics; t++)
-              bestAssignment[p][t] = assigned[p][t];
-
-          if (debug)
-            System.out.println(&quot;BEST ASSIGNMENT&quot;);
-        }
-      }
-      
-      if (target &lt; bestTarget)
-      {
-        if (rand.nextInt(100) &gt;= 100)
-        {
-          // take back
-          assigned[p1][t1] = 9;
-          assigned[p1][t2] = 0;
-          assigned[p2][t1] = 0;
-          assigned[p2][t2] = 9;
-          target = lastTarget;
-          
-          if (debug)
-            System.out.println(&quot;better, but staying.&quot;);
-        }
-        else
-        {
-          // accept
-          bestTarget = target;
-          
-          if (debug)
-            System.out.println(&quot;better, moving.&quot;);
-        }
-      }
-      else
-      {
-        if (rand.nextInt(100) &gt;= 0)
-        {
-          // take back
-          assigned[p1][t1] = 9;
-          assigned[p1][t2] = 0;
-          assigned[p2][t1] = 0;
-          assigned[p2][t2] = 9;
-          target = lastTarget;
-          if (debug)
-            System.out.println(&quot;worse, staying&quot;);
-        }
-        else
-        {
-          // accept
-          bestTarget = target;
-          if (debug)
-            System.out.println(&quot;worse, but moving.&quot;);
-        }
-      }
-    }
-
-    for (int p = 0; p &lt; solver.dimPersons; p++)
-      for (int t = 0; t &lt; solver.dimTopics; t++)
-        assigned[p][t] = bestAssignment[p][t];
-
-    if (debug)
-    {
-      target = targetValue();
-      System.out.println(this + &quot;target=&quot; + target + &quot;  bestTargetTotal=&quot;
-                         + bestTargetTotal);
-    }
-  }
-
-  /**
-   * Assign the roles to produce a solution.
-   * After calling this method, isValidSoution() should be used
-   * to check whether a valid solution has been reached.
-   */
-  void assignRoles()
-  {
-    int dimRoles = solver.getRoles().getNumber();
-
-    for (int topic = 0;  topic &lt; solver.dimTopics;  ++topic)
-      Arrays.fill(topicRole[topic], 0);
-
-    for (int person = 0;  person &lt; solver.dimPersons;  ++person)
-      Arrays.fill(personRole[person], 0);
-
-    for (int as = 0;  as &lt; nAssignments + 1;  ++as)
-      Arrays.fill(seqPersons[as], 0);
-
-    int topicLimit = solver.dimPersons / dimSessions / dimRoles;
-    int personLimit = solver.dimTopics / dimSessions / dimRoles;
-
-    // for every role we repeat the same procedure:
-    // we try to allocate the role according to the preference of the person
-    // we perform backtracking to find a valid solution
-    boolean debug = false;
-
-    if (debug)
-      System.out.println(this);
-
-    // we define the sequence in which we want to assign roles to the persons
-    // we change the sequence of persons for each step to prevent a bias
-		int noStep   = 0;
-		int maxSteps = 100000; // Integer.MAX_VALUE;
-		solved = true;
-		
-    for (int n = 0; n &lt; nAssignments; n++)
-    {
-      int p = n % solver.dimPersons;
-      int cycle = n / solver.dimPersons;
-      
-      if (cycle % 2 == 0)
-        seqPersons[n][0] = p;
-      else
-        seqPersons[n][0] = solver.dimPersons - 1 - p;
-    }
-
-    for (int n = 0; n &lt; nAssignments; n++)
-    {
-			if (++noStep &gt; maxSteps)
-			{
-			  solved = false;
-			  break;
-			}
-			
-      int r = (n / (nAssignments / dimRoles)) + 1;
-      int p = seqPersons[n][0];
-      boolean ok = false;
-      int t = 0, prio;
-      
-      for (prio = seqPersons[n][1]; prio &lt; solver.dimTopics; prio++)
-      {
-        t = persons.prefInx[p][prio];
-        
-        if (assigned[p][t] == 9)
-        {
-          if (debug)
-            System.out.print(&quot;n=&quot; + n + &quot; r=&quot; + r + &quot; p=&quot; + p + &quot; t=&quot; + t);
-          
-          // try to assign the role
-          if (topicRole[t][r] &lt; topicLimit &amp;&amp; personRole[p][r] &lt; personLimit)
-          {
-            assigned[p][t] = r;
-            topicRole[t][r] += 1;
-            personRole[p][r] += 1;
-            
-            if (debug)
-              System.out.println(&quot;  assigned.&quot;);
-            
-            ok = true;
-            break;
-          }
-          else
-          {
-            ok = false;
-            
-            if (debug)
-              System.out.println(&quot;  not possible.&quot;);
-          }
-        }
-      }
-      
-      if (ok)
-      { // going forward, reset minPrio for next n
-        seqPersons[n][1] = prio + 1;
-        seqPersons[n + 1][1] = 0;
-      }
-      else
-      { // back tracking
-        n -= 1;
-
-        p = seqPersons[n][0];
-        t = persons.prefInx[p][seqPersons[n][1] - 1];
-        assigned[p][t] = 9;
-        topicRole[t][r] -= 1;
-        personRole[p][r] -= 1;
-        n -= 1;
-      }
-    }
-    
-		// System.out.println (noStep + &quot; steps performed.&quot;);
-		doStatistics();
-  }
-
-  /**
-   * Evaluate the solution and set the statistical values.
-   */
-  protected void doStatistics()
-  {
-    float  total = 0;
-    int    sumMax = 0;
-    int    pval[] = new int[solver.dimPersons];
-    int    val = 0;
-    
-    for (int p = 0; p &lt; solver.dimPersons; p++)
-    {
-      for (int t = 0; t &lt; solver.dimTopics; t++)
-        if (assigned[p][t] &gt; 0)
-          pval[p] += pref[p][t];
-      
-      val += pval[p];
-    }
-    
-    double mean = (val * 1.0 / solver.dimPersons);
-    double dev = 0;
-    
-    for (int p = 0;  p &lt; solver.dimPersons;  p++)
-      dev += (mean - pval[p]) * (mean - pval[p]);
-    
-    dev = Math.sqrt(dev / solver.dimPersons);
-         
-    for (int p = 0; p &lt; solver.dimPersons; p++)
-    {
-      int sum = -(solver.dimTopics / dimSessions)
-                * ((solver.dimTopics / dimSessions) - 1) / 2;
-      
-      for (int t = 0; t &lt; solver.dimTopics; t++)
-        if (assigned[p][t] &gt; 0)
-          sum += pref[p][t]; // *pref[p][t])
-      
-      personSum[p] = sum;
-      
-      total += sum;
-      
-      if (sumMax &lt; sum)
-        sumMax = sum;
-    }
-
-    meanDeviation = total / solver.dimPersons;
-    maxDeviation = sumMax;  
-    stdDeviation = Math.sqrt(dev);
-  }
-
-  /**
-   * Create a Solution object from the current solution.
-   * 
-   * @param index this is the current number of the solution.
-   *              Will be used to give the solution an initial name
-   *              (&quot;Solution &lt;index&gt;&quot;).
-   * @return the new Solution object.
-   */
-  public Solution createSolution(int index)
-  {
-    if (!solved)
-      return null;
-    
-    Solution s = new Solution(solver);
-
-    for (int gr = 0;  gr &lt; groups.length;  ++gr)
-    {
-      int groupIndex = 0;
-      
-      for (int t = 0;  t &lt; solver.dimTopics;  ++t)
-        if (groups[t] == gr)
-          s.setGroupElement(gr, groupIndex++, t);
-    }
-    
-    for (int p = 0; p &lt; solver.dimPersons; p++)
-    {
-      for (int t = 0; t &lt; solver.dimTopics; t++)
-        s.setRole(p, t, assigned[p][t]);
-      
-      s.setPersonSum(p, personSum[p]);
-    }
-
-    s.setStatistics(meanDeviation, maxDeviation, stdDeviation, targetValue());
-
-    StringBuffer name = new StringBuffer(&quot;Solution &quot; + (index+1));
-    name.append(&quot;: &quot;);
-    name.append(compactFormat.format(s.getMeanDeviation()));
-    name.append(&quot; - &quot;);
-    name.append(compactFormat.format(s.getMaximumDeviation()));
-    name.append(&quot; - &quot;);
-    name.append(compactFormat.format(s.getStandardDeviation()));
-    s.setName(name.toString());
-    
-    return s;
-  }
-  
-  public String toString()
-  {
-		if (!solved) 
-		  return &quot;suppressing output of unsolved matrix ...\n&quot;;
-    
-    // return the final allocation matrix
-    StringBuffer s = new StringBuffer(persons.emptyName() + &quot;   &quot; + topics.toHeaderString(&quot; &quot;) + &quot;\n&quot;);
-         
-    for (int p = 0; p &lt; solver.dimPersons; p++)
-    {
-      s.append(persons.getName(p) + &quot;  &quot;);
-
-      for (int t = 0; t &lt; solver.dimTopics; t++)
-        s.append(&quot; &quot; + solver.getRoles().getNameExtended(assigned[p][t]));
-
-      String tmp = &quot;       &quot; + personSum[p];
-
-      s.append(tmp.substring(tmp.length() - 5) + &quot;\n&quot;);
-    }
-    
-    s.append(persons.emptyName() + &quot;   &quot; + topics.toHeaderString(&quot; &quot;) + &quot;\n&quot;);
-    s.append(&quot;    mittlere Abweichung=&quot; + meanDeviation
-         + &quot;    maximale Abweichung=&quot; + maxDeviation  
-         + &quot;    Standardabw.=&quot; + stdDeviation
-         + &quot;    target=&quot; + targetValue()
-         + &quot;\n\n&quot;);
-    
-    return s.toString();
-  }
-}
\ No newline at end of file

Modified: trunk/openSess/Persons.java
===================================================================
--- trunk/openSess/Persons.java	2005-03-15 13:52:49 UTC (rev 17)
+++ trunk/openSess/Persons.java	2005-03-20 13:54:06 UTC (rev 18)
@@ -9,7 +9,7 @@
  * Copyright 2005 Gero Scholz, Andreas Wickner
  * 
  * Created:     2005-02-11 
- * Revision ID: $Id$
+ * Revision ID: $Id: Persons.java 10 2005-03-04 18:45:41Z awickner $
  * 
  * 2005-02-22/GS: Algorithm bug fixes
  * 
@@ -41,8 +41,8 @@
   private DefaultListModel names;
   private static int       nameLen = 30;
   
-  public int              pref[][];    /** the topics ordered by preference */
-  public int              prefInx[][]; /** the rank of the preference for each topic */
+  private int              pref[][];    /** the topics ordered by preference */
+  private int              prefInx[][]; /** the rank of the preference for each topic */
 
   /**
    * Constructs a new Persons object. Uses the configuration data in a
@@ -50,22 +50,22 @@
    * 
    * @param solver the Solver object.
    */
-  public Persons(Solver solver)
+  public Persons(Solver solver, int dimPersons, int dimTopics)
   {
     this.solver = solver;
-
+    
     // store the names
     names = new DefaultListModel();
     
-    for (int p = 0; p &lt; solver.dimPersons; p++)
+    for (int p = 0; p &lt; dimPersons; p++)
       names.addElement(&quot;Person &quot; + (p+1));
 
     // create an initial preference structure
-    pref = new int[solver.dimPersons][solver.dimTopics];
-    prefInx = new int[solver.dimPersons][solver.dimTopics];
-    for (int p = 0; p &lt; solver.dimPersons; p++)
+    pref = new int[dimPersons][dimTopics];
+    prefInx = new int[dimPersons][dimTopics];
+    for (int p = 0; p &lt; dimPersons; p++)
     {
-      for (int t = 0; t &lt; solver.dimTopics; t++)
+      for (int t = 0; t &lt; dimTopics; t++)
       {
         prefInx[p][t] = pref[p][t] = t;
       }
@@ -130,6 +130,19 @@
   }
   
   /**
+   * For the indicated person, return the index that the specified
+   * topic has in the preferences list.
+   *  
+   * @param person the person index.
+   * @param topic  the topic index.
+   * @return the index in the preferences list.
+   */
+  public int getPreferenceIndex(int person, int topic)
+  {
+    return prefInx[person][topic];
+  }
+  
+  /**
    * For the indicated person, swap the topics at indeces &quot;first&quot; and &quot;second&quot;
    * in the preferences list.
    * 
@@ -167,12 +180,15 @@
   {
     // assign random preferences by randomly swapping pairs of
     // the initial preference structure
-    for (int p = 0;  p &lt; solver.dimPersons;  p++)
+    int dimPersons = solver.getPersons().getNumber();
+    int dimTopics  = solver.getTopics().getNumber();
+    
+    for (int p = 0;  p &lt; dimPersons;  p++)
     {
       for (int i = 0;  i &lt; shuffle;  i++)	
       {
-        int j = rand.nextInt(solver.dimTopics);
-        int k = rand.nextInt(solver.dimTopics);
+        int j = rand.nextInt(dimTopics);
+        int k = rand.nextInt(dimTopics);
         int tmp = pref[p][j];
         pref[p][j] = pref[p][k];
         pref[p][k] = tmp;
@@ -186,8 +202,11 @@
    */
   protected void createPrefInx()
   {
-    for (int p = 0; p &lt; solver.dimPersons; p++)
-      for (int t = 0; t &lt; solver.dimTopics; t++)
+    int dimPersons = solver.getPersons().getNumber();
+    int dimTopics  = solver.getTopics().getNumber();
+
+    for (int p = 0; p &lt; dimPersons; p++)
+      for (int t = 0; t &lt; dimTopics; t++)
         prefInx[p][pref[p][t]] = t;
   }
 
@@ -198,11 +217,14 @@
    */
   public String ranks()
   {
+    int dimPersons = solver.getPersons().getNumber();
+    int dimTopics  = solver.getTopics().getNumber();
     String s = new String();
-    for (int p = 0; p &lt; solver.dimPersons; p++)
+    
+    for (int p = 0; p &lt; dimPersons; p++)
     {
       s += getName(p) + &quot;:&quot;;
-      for (int t = 0; t &lt; solver.dimTopics; t++)
+      for (int t = 0; t &lt; dimTopics; t++)
       {
         String tmp = &quot;   &quot; + (pref[p][t] + 1);
         s += tmp.substring(tmp.length() - 3);
@@ -239,15 +261,18 @@
    */
   public String toString()
   {
+    int dimPersons = solver.getPersons().getNumber();
+    int dimTopics  = solver.getTopics().getNumber();
     String s = new String();
-    for (int p = 0; p &lt; solver.dimPersons; p++)
+    
+    for (int p = 0; p &lt; dimPersons; p++)
     {
       s += getName(p) + &quot;:  &quot;;
-      for (int t = 0; t &lt; solver.dimTopics; t++)
+      for (int t = 0; t &lt; dimTopics; t++)
       {
       	// changed prefInx to pref -- GS - 2005-02-22
         s += solver.getTopics().getName(pref[p][t]);
-        if (t &lt; solver.dimTopics - 1)
+        if (t &lt; dimTopics - 1)
           s += &quot;__&quot;;
       }
       s += &quot;\n&quot;;

Modified: trunk/openSess/Roles.java
===================================================================
--- trunk/openSess/Roles.java	2005-03-15 13:52:49 UTC (rev 17)
+++ trunk/openSess/Roles.java	2005-03-20 13:54:06 UTC (rev 18)
@@ -57,10 +57,9 @@
    * 
    * @param solver the Solver object containing configuration information.
    */
-  public Roles(Solver solver)
+  public Roles(Solver solver, int dimRoles)
   {
     names = new DefaultListModel();
-    int dimRoles = solver.dimRoles;
     minPerSession = new int[dimRoles];
     maxPerSession = new int[dimRoles];
     

Modified: trunk/openSess/Solution.java
===================================================================
--- trunk/openSess/Solution.java	2005-03-15 13:52:49 UTC (rev 17)
+++ trunk/openSess/Solution.java	2005-03-20 13:54:06 UTC (rev 18)
@@ -6,7 +6,7 @@
  * Copyright 2005 Andreas Wickner
  * 
  * Created:     18.02.2005
- * Revision ID: $Id$
+ * Revision ID: $Id: Solution.java 10 2005-03-04 18:45:41Z awickner $
  * 
  * This file is part of OpenSess.
  * OpenSess is free software; you can redistribute it and/or modify it 
@@ -49,12 +49,15 @@
    */
   Solution(Solver solver)
   {
+    int dimTopics = solver.getTopics().getNumber();
+    int dimSessions = solver.getSessionNumber();
+    int dimPersons  = solver.getPersons().getNumber(); 
     this.solver = solver;
-    groupNumber = solver.getTopics().getNumber() / solver.getSessionNumber();
-    groupSize   = solver.getSessionNumber();
-    group = new int[groupNumber][groupSize];
-    role = new int[solver.getPersons().getNumber()][solver.getTopics().getNumber()];
-    personSum = new int[solver.getPersons().getNumber()];
+    groupNumber = dimTopics / dimSessions;
+    groupSize   = dimSessions;
+    group       = new int[groupNumber][groupSize];
+    role        = new int[dimPersons][dimTopics];
+    personSum   = new int[dimPersons];
   }
 
   /**
@@ -124,6 +127,14 @@
     return -1;
   }
   
+  public void clearRoles()
+  {
+    int dimPersons = solver.getPersons().getNumber();
+    
+    for (int person = 0;  person &lt; dimPersons;  ++person)
+      Arrays.fill(role[person], 0);  
+  }
+  
   /**
    * Return the role of the specified person with regard to the specified topic.
    * @param person the person.
@@ -145,6 +156,43 @@
   {
     return personSum[person];
   }
+	
+	/**
+	 * Calculates the target value of the current assignment.
+	 * 
+	 * @return the target value.
+	 */
+  protected int calculateTargetValue()
+  {
+    Persons persons    = solver.getPersons();
+    Topics  topics     = solver.getTopics();
+    int     dimPersons = persons.getNumber();
+    int     dimTopics  = topics.getNumber();
+    
+		int pval[] = new int[dimPersons];
+    int val = 0;
+
+    for (int p = 0;  p &lt; dimPersons;  ++p)
+    {
+      for (int t = 0;  t &lt; dimTopics; ++t)
+        if (getRole(p, t) &gt; 0)
+          pval[p] += persons.getPreferenceIndex(p, t);
+
+      val += pval[p];
+    }
+    
+    double mean = (val * 1.0 / dimPersons);
+    double dev = 0;
+    
+    for (int p = 0;  p &lt; dimPersons;  ++p)
+      dev += (mean - pval[p]) * (mean - pval[p]);
+
+    dev = Math.sqrt(dev / dimPersons);
+    val += solver.getBalancingWeight() * dev;
+    targetValue = val;
+    
+    return val;
+  }
   
   /**
    * Return the mean deviation of this solution.
@@ -228,22 +276,58 @@
   {
     personSum[person] = sum;
   }
-
+  
   /**
-   * Set the statistical values of this solution.
-   * 
-   * @param meanDeviation the mean deviation.
-   * @param maxDeviation  the maximum deviation.
-   * @param stdDeviation  the standard deviation.
-   * @param targetValue   the target value.
+   * Evaluate the solution and set the statistical values.
    */
-  public void setStatistics(double meanDeviation, double maxDeviation, 
-                            double stdDeviation, int targetValue)
+  protected void evaluate()
   {
-    this.meanDeviation = meanDeviation;
-    this.maxDeviation  = maxDeviation;
-    this.stdDeviation  = stdDeviation;
-    this.targetValue   = targetValue;
+    Persons persons = solver.getPersons();
+    int     dimPersons = persons.getNumber();
+    int     dimTopics  = solver.getTopics().getNumber();
+    int     dimSessions = solver.getSessionNumber();
+    float   total = 0;
+    int     sumMax = 0;
+    int     pval[] = new int[dimPersons];
+    int     val = 0;
+    
+    for (int p = 0; p &lt; dimPersons; p++)
+    {
+      for (int t = 0; t &lt; dimTopics; t++)
+        if (getRole(p, t) &gt; 0)
+          pval[p] += persons.getPreferenceIndex(p, t);
+      
+      val += pval[p];
+    }
+    
+    double mean = ((double)val) / dimPersons;
+    double dev = 0;
+    
+    for (int p = 0;  p &lt; dimPersons;  p++)
+      dev += (mean - pval[p]) * (mean - pval[p]);
+    
+    dev = Math.sqrt(dev / dimPersons);
+         
+    for (int p = 0; p &lt; dimPersons; p++)
+    {
+      int sum = -(dimTopics / dimSessions)
+                * ((dimTopics / dimSessions) - 1) / 2;
+      
+      for (int t = 0; t &lt; dimTopics; t++)
+        if (getRole(p, t) &gt; 0)
+          sum += persons.getPreferenceIndex(p, t); 
+      
+      personSum[p] = sum;
+      
+      total += sum;
+      
+      if (sumMax &lt; sum)
+        sumMax = sum;
+    }
+
+    meanDeviation = total / dimPersons;
+    maxDeviation  = sumMax;  
+    stdDeviation  = dev;
   }
 
   /**
@@ -301,4 +385,37 @@
     
     Indenter.println(stream, level, &quot;&lt;/solution&gt;&quot;);
   }
+  
+  public String toString()
+  {
+    Persons persons = solver.getPersons();
+    Topics  topics  = solver.getTopics();
+    int     dimPersons = persons.getNumber();
+    int     dimTopics  = topics.getNumber();
+    
+    // return the final allocation matrix
+    StringBuffer s = new StringBuffer(persons.emptyName() + &quot;   &quot; + topics.toHeaderString(&quot; &quot;) + &quot;\n&quot;);
+         
+    for (int p = 0; p &lt; dimPersons; p++)
+    {
+      s.append(persons.getName(p) + &quot;  &quot;);
+
+      for (int t = 0; t &lt; dimTopics; t++)
+        s.append(&quot; &quot; + solver.getRoles().getNameExtended(getRole(p, t)));
+
+      String tmp = &quot;       &quot; + personSum[p];
+
+      s.append(tmp.substring(tmp.length() - 5) + &quot;\n&quot;);
+    }
+    
+    s.append(persons.emptyName() + &quot;   &quot; + topics.toHeaderString(&quot; &quot;) + &quot;\n&quot;);
+    s.append(&quot;    mittlere Abweichung=&quot; + getMeanDeviation()
+         + &quot;    maximale Abweichung=&quot; + getMaximumDeviation()  
+         + &quot;    Standardabw.=&quot; + getStandardDeviation()
+         + &quot;    target=&quot; + calculateTargetValue()
+         + &quot;\n\n&quot;);
+    
+    return s.toString();
+  }
+
 }

Modified: trunk/openSess/Solver.java
===================================================================
--- trunk/openSess/Solver.java	2005-03-15 13:52:49 UTC (rev 17)
+++ trunk/openSess/Solver.java	2005-03-20 13:54:06 UTC (rev 18)
@@ -2,7 +2,7 @@
  * Copyright 2005 Gero Scholz, Andreas Wickner
  * 
  * Created:     2005-02-11 
- * Revision ID: $Id$
+ * Revision ID: $Id: Solver.java 10 2005-03-04 18:45:41Z awickner $
  * 
  * 2005-02-14/AW: Changes to decrease excessive memory allocation/deallocation
  * 2005-02-22/GS: Algorithm bug fixes
@@ -24,6 +24,9 @@
  */
 
 package openSess;
+import java.text.NumberFormat;
+import java.util.Arrays;
+import java.util.Random;
 import java.util.Vector;
 
 import javax.swing.DefaultListModel;
@@ -33,39 +36,41 @@
  * It maintains the dimensions of the various object lists
  * as well as the object lists themselves. It provides
  * the solution algorithm and analysis functions.
- * 
- * TODO: Maybe the class is a bit too central and should be
- *       restructured. Also, the separation of concerns between
- *       Solver and PTAlloc is not quite clear (andreas).
+ * The algorithm must be executed in a different thread, therefore
+ * it is implemented as the doTask() method of a TaskMonitor.
  *  
  * @author Gero Scholz
  */
 public class Solver
+extends TaskMonitor
 {
-  int                      dimPersons;
-  int                      dimRoles;
-  int                      dimTopics;
   private int              dimSessions;
   private int              dimShuffle   = 100;  // the greater the more randomly
                                                 // preferences will
                                                 // be distributed.
                                                 // should be 3 * dimTopics or more, values &lt; 3 will lead
                                                 // to pathologic / trivial distributions
-  int                      dimBalancing = 20;   // weight of a component in the
+  private int              dimBalancing = 20;   // weight of a component in the
                                                 // target function which
                                                 // favors evenly distributed solutions; try values between
                                                 // 0 and 100 (or greater); large values will usually tend
                                                 // to make the overall result worse
-
   private Topics           topics;
   private Persons          persons;
   private Roles            roles;
-  private int              current      = 0;
-  private boolean          taskDone     = false;
-  private boolean          taskCanceled = false;
-  private String           statMessage;
   private Vector           solutions;
   private DefaultListModel solutionNames;
+  private int              dimTryTopicClustering;
+  private int              dimTryPersonAssignment;
+  private int              dimTryAlloc;
+  private boolean          debug;
+  private Solution         solution;
+  private int              bestAssignment[][];
+  private int              topicRole[][];
+  private int              personRole[][];
+  private int              seqPersons[][];
+  private NumberFormat     compactFormat;
+  private boolean          solved;
   
   /*
    * currently there is a tendency to find an ideal solution for some persons
@@ -73,14 +78,6 @@
    * function of the allocation process could change this.
    */
 
-  /*
-  public static void main(String[] args)
-  {
-    System.out.println(&quot;\nOpenSess allocation solver 0.1 by Gero Scholz&quot;);
-    new Solver().solve(2, 3, 100000);
-  }
-  */
-  
   /**
    * Create a new Solver with the specified dimensions.
    * 
@@ -91,21 +88,27 @@
    */
   public Solver(int dimTopics, int dimPersons, int dimRoles, int dimSessions)
   {
-    this.dimTopics   = dimTopics;
-    this.dimPersons  = dimPersons;
-    this.dimRoles    = dimRoles;
     this.dimSessions = dimSessions;
 
-    topics        = new Topics(this);
-    persons       = new Persons(this);
-    roles         = new Roles(this);
+    topics        = new Topics(this, dimTopics);
+    persons       = new Persons(this, dimPersons, dimTopics);
+    roles         = new Roles(this, dimRoles);
     solutions     = new Vector();
     solutionNames = new DefaultListModel();
-    
-    //persons.setRandomPrefs(new Random(4711),dimShuffle);
   }
 
   /**
+   * Return the weight of a component in the target function which
+   * favors evenly distributed solutions.; try values between
+   * 
+   * @return the balancing weight.
+   */
+  public int getBalancingWeight()
+  {
+    return dimBalancing;
+  }
+  
+  /**
    * Return the number of sessions.
    * 
    * @return the number of sessions.
@@ -178,10 +181,7 @@
   
   /**
    * Start a solution calculation as a separate task.
-   * This is neccessary in order not to block the GUI thread,
-   * however I do not know why this has to be so complicated.
-   * All this impressive handwaving was copied from Javasoft 
-   * example code...
+   * This is neccessary in order not to block the GUI thread.
    * 
    * @param dimTryTopicClustering  the number of topic clusterings to try.
    * @param dimTryPersonAssignment the number of topic/person assignments to try.
@@ -192,102 +192,19 @@
                              int dimTryAlloc)
   {
     final Solver theSolverItself = this;
-    final int clusterings = dimTryTopicClustering;
-    final int assignments = dimTryPersonAssignment;
-    final int allocs = dimTryAlloc;
-    
-    final SwingWorker worker = new SwingWorker()
-    {
-      public Object construct()
-      {
-        current = 0;
-        taskDone = false;
-        taskCanceled = false;
-        statMessage = null;
-        return new SolverTask(theSolverItself, clusterings, assignments, allocs); 
-      }
-    };
-    
-    worker.start();
+    this.dimTryTopicClustering = dimTryTopicClustering;
+    this.dimTryPersonAssignment = dimTryPersonAssignment;
+    this.dimTryAlloc = dimTryAlloc;
+    startTask();
   }
   
-  /**
-   * SolverTask wraps the actual work to do in a way that is
-   * compatible with the SwingWorker.
-   * 
-   * @author andreas
-   */
-  private class SolverTask
-  {
-    /**
-     * The constructor contains the actual work to do
-     * (which is our solution calculation).
-     * 
-     * @param solver the Solver object.
-     * @param dimTryTopicClustering  the number of topic clusterings to try.
-     * @param dimTryPersonAssignment the number of topic/person assignments to try.
-     * @param dimTryAlloc            the maximum number of assignments to try.
-     */
-    public SolverTask(Solver solver, int dimTryTopicClustering, 
-                      int dimTryPersonAssignment,
-                      int dimTryAlloc)
-    {
-      solver.solve(dimTryTopicClustering, dimTryPersonAssignment, dimTryAlloc);
-    }
-  };
-  
-  /**
-   * Return the current progress (which is in the range
-   * 0 to (dimTryTopicClustering*dimTryPersonAssignment)).
-   * 
-   * @return the current progress.
-   */
-  public int getCurrent()
-  {
-    return current;
-  }
 
   /**
-   * Can be used to cancel the task from the outside.
-   */
-  public void stop()
-  {
-    taskCanceled = true;
-    statMessage = null;
-  }
-
-  /**
-   * Returns whether the task has completed.
-   * 
-   * @return true if completed, false otherwise.
-   */
-  public boolean isDone()
-  {
-    return taskDone;
-  }
-
-  /**
-   * Returns the most recent status message, or null
-   * if there is no current status message.
-   * 
-   * @return a status message.
-   */
-  public String getMessage()
-  {
-    return statMessage;
-  }
-
-  /**
    * Perform the calculation of solutions.
    * This should not be called in a GUI thread, use startSolverTask()
    * instead.
-   * 
-   * @param dimTryTopicClustering  the number of topic clusterings to try.
-   * @param dimTryPersonAssignment the number of topic/person assignments to try.
-   * @param dimTryAlloc            the maximum number of assignments to try.
    */
-  public void solve(int dimTryTopicClustering, int dimTryPersonAssignment,
-                    int dimTryAlloc)
+  protected void doTask()
   {
   	// added update of preference index -- GS - 2005-02-22
     persons.createPrefInx();
@@ -319,12 +236,14 @@
     // make several tries
     solutionNames.removeAllElements();
     solutions.removeAllElements();
+    allocate();
+
     Vector  done = new Vector();
-    PTAlloc pt   = new PTAlloc(this);
-
+    int     dimTopics = topics.getNumber();
+    
     for (int tryT = 0; tryT &lt; dimTryTopicClustering; tryT++)
     {
-      statMessage = &quot;Topic Clustering Attempt &quot; + tryT;
+      setMessage(&quot;Topic Clustering Attempt &quot; + tryT);
       
       int topicGroup[] = topics.createGroup(dimSessions, done, dimTopics
                                                                * dimTopics
@@ -341,27 +260,416 @@
 
       // for each clustering we try several assigments
       // of persons to topics (and roles)
-      
       for (int tryP = 0; tryP &lt; dimTryPersonAssignment; tryP++)
       {
-        current = tryT*dimTryPersonAssignment + tryP;
+        setCurrent(tryT*dimTryPersonAssignment + tryP);
         
-        if (taskCanceled)
+        if (taskWasCanceled())
           return;
         
         // first the assignment is done without a specific role
-        pt.init(topicGroup, dimTryAlloc, tryP * 4711 + 8812);
+        assignPersonsToSessions(topicGroup, dimTryAlloc, tryP * 4711 + 8812);
         
         // thereafter the roles are assigned
-        pt.assignRoles();
+        assignRoles();
 
         // System.out.print(pt);
         
-        if (pt.isValidSolution())
-          addSolution(pt.createSolution(solutions.size()));
+        if (isValidSolution())
+          addSolution(createSolution(solutions.size()));
       }
     }
+  }
+  
+  /**
+   * Return true if the PTAlloc currently holds a valid solution.
+   * 
+   * @return true if the solution is valid, false otherwise.
+   */
+	public boolean isValidSolution()
+	{
+	  return solved;
+	}
+
+  /**
+   * Allocates global data structures for the algorithm.
+   * It creates the necessary arrays which are used in subsequent
+   * calculations. Each calculation must be set up by a call to 
+   * assignPersonsToSessions().
+   */
+  public void allocate()
+  {
+    debug            = false;
+    this.solved      = false;
     
-    taskDone = true;
+    int     dimPersons     = persons.getNumber();
+    int     dimTopics      = topics.getNumber();
+    int     dimRoles       = roles.getNumber();
+    int     nAssignments = dimPersons * dimTopics / dimSessions;
+    
+    bestAssignment   = new int[dimPersons][dimTopics];
+    topicRole        = new int[dimTopics][dimRoles + 1];
+    personRole       = new int[dimPersons][dimRoles  + 1];
+    seqPersons       = new int[nAssignments + 1][2];
+    
+    // Prepare a number formatter
+    compactFormat = NumberFormat.getInstance();
+    compactFormat.setMinimumFractionDigits(2);
+    compactFormat.setMaximumFractionDigits(2);
+    
+    if (debug)
+    {
+      System.out
+          .println(&quot;\nPersonen und Pr&#228;ferenzen bei gegebener Themengruppierung:&quot;);
+      System.out.println(&quot;\n&quot; + persons.emptyName() + &quot;:   &quot;
+                         + topics.toHeaderString(&quot;   &quot;));
+      for (int p = 0;  p &lt; dimPersons;  p++)
+      {
+        System.out.print(persons.getName(p) + &quot;:&quot;);
+        for (int t = 0;  t &lt; dimTopics; t++)
+        {
+          String tmp = &quot;    &quot; + persons.getPreferenceIndex(p, t);
+          System.out.print(tmp.substring(tmp.length() - 4));
+        }
+        
+        System.out.println();
+      }
+    }
   }
+
+  /**
+   * Initialize a calculation by performing a first assignment 
+   * without specific roles.
+   * 
+   * @param groups  the group of topics to work on.
+   * @param tries   the maximum number of tries.
+   * @param seed    the seed for the random number generator.
+   */
+  public void assignPersonsToSessions(int[] groups, int tries, long seed)
+  {
+    int     dimPersons     = persons.getNumber();
+    int     dimTopics      = topics.getNumber();
+    int     dimSessions    = getSessionNumber();
+    int     unassignedRole = getRoles().getNumber() + 1;  // Marker for an unassigned role
+
+    // Start a new solution
+    solution = new Solution(this);
+    
+    // Remember the topic grouping in the solution
+    for (int gr = 0;  gr &lt; groups.length;  ++gr)
+    {
+      int groupIndex = 0;
+      
+      for (int t = 0;  t &lt; dimTopics;  ++t)
+        if (groups[t] == gr)
+          solution.setGroupElement(gr, groupIndex++, t);
+    }
+
+    // Erase bestAssignment
+    for (int person = 0;  person &lt; dimPersons;  ++person)
+      Arrays.fill(bestAssignment[person], 0);
+    
+    // we generate a legal assignment as a starting point;
+    for (int gr = 0; gr &lt; groups.length / dimSessions; gr++)
+      for (int p = 0; p &lt; dimPersons; p++)
+      {
+        int seq = 0;
+        
+        for (int t = 0; t &lt; dimTopics; t++)
+          if (groups[t] == gr)
+          {
+            if (p / (dimPersons / dimSessions) == seq)
+              solution.setRole(p, t, unassignedRole);
+
+            ++seq;
+          }
+      }
+
+    int target = solution.calculateTargetValue();
+
+    if (debug)
+    {
+      System.out.println(&quot;\n&quot; + persons.emptyName() + &quot;:  &quot;
+                         + topics.toHeaderString(&quot; &quot;));
+      System.out.println(this + &quot;target=&quot; + target);
+    }
+
+    // again we apply simulated annealing; we try to swap people
+    // between sessions of the same group
+
+    // simulated annealing; we look for better solutions and
+    // adopt them in most cases (80%) as a starting point for the next trial
+    // sometimes we accept worse solutions and temporarily lower the
+    // expectation level
+
+    int bestTargetTotal = Integer.MAX_VALUE;
+    int bestTarget = Integer.MAX_VALUE;
+    int lastTarget = target;
+    Random rand = new Random();
+    
+    if (seed != 0)
+      rand = new Random(seed);
+
+    for (int y = 0; y &lt; tries; y++)
+    {
+      // modify constellation, later restore possible
+      int p1 = 0, t1 = 0, p2 = 0, t2 = 0;
+      p1 = rand.nextInt(dimPersons);
+      t1 = rand.nextInt(dimTopics / dimSessions);
+      // look for a topic the selected person is assigned to
+      for (int t = 0; t &lt; dimTopics; t++)
+        if (solution.getRole(p1, t) &gt; 0)
+          if (t1-- &lt;= 0)
+          {
+            t1 = t;
+            break;
+          }
+
+        // pick a member of another topic of the same session
+      int n = rand.nextInt(dimPersons - dimPersons / dimSessions);
+      
+      for (int t = 0;  t &lt; dimTopics;  t++)
+        if (groups[t] == groups[t1] &amp;&amp; t1 != t)
+          for (int p = 0;  p &lt; dimPersons;  p++)
+            if (solution.getRole(p, t) &gt; 0 &amp;&amp; n-- &lt;= 0)
+            {
+              p2 = p;
+              t2 = t;
+              break;
+            }
+      
+      solution.setRole(p1, t1, 0);
+      solution.setRole(p1, t2, unassignedRole);
+      solution.setRole(p2, t1, unassignedRole);
+      solution.setRole(p2, t2, 0);
+
+      // calculate target value
+      lastTarget = target;
+      target = solution.calculateTargetValue();
+
+      if (debug)
+      {
+        System.out.println(&quot;\np1=&quot; + p1 + &quot; t1=&quot; + topics.getName(t1)
+                           + &quot;  /  p2=&quot; + p2 + &quot; t2=&quot; + topics.getName(t2));
+        System.out.println(this + &quot;target=&quot; + target + &quot;   (&quot; + bestTarget
+                           + &quot;)  (&quot; + bestTargetTotal + &quot;)&quot;);
+      }
+
+      if (target &lt; bestTargetTotal)
+      {
+        // check if solution is known already
+        boolean known = false;
+        
+        if (!known)
+        {
+          bestTargetTotal = target;
+          // store best result
+          for (int p = 0; p &lt; dimPersons; p++)
+            for (int t = 0; t &lt; dimTopics; t++)
+              bestAssignment[p][t] = solution.getRole(p, t);
+
+          if (debug)
+            System.out.println(&quot;BEST ASSIGNMENT&quot;);
+        }
+      }
+      
+      if (target &lt; bestTarget)
+      {
+        if (rand.nextInt(100) &gt;= 100)
+        {
+          // take back
+          solution.setRole(p1, t1, unassignedRole);
+          solution.setRole(p1, t2, 0);
+          solution.setRole(p2, t1, 0);
+          solution.setRole(p2, t2, unassignedRole);
+          target = lastTarget;
+          
+          //if (debug)
+            System.out.println(&quot;better, but staying.&quot;);
+        }
+        else
+        {
+          // accept
+          bestTarget = target;
+          
+          if (debug)
+            System.out.println(&quot;better, moving.&quot;);
+        }
+      }
+      else
+      {
+        if (rand.nextInt(100) &gt;= 0)
+        {
+          // take back
+          solution.setRole(p1, t1, unassignedRole);
+          solution.setRole(p1, t2, 0);
+          solution.setRole(p2, t1, 0);
+          solution.setRole(p2, t2, unassignedRole);
+          target = lastTarget;
+          if (debug)
+            System.out.println(&quot;worse, staying&quot;);
+        }
+        else
+        {
+          // accept
+          bestTarget = target;
+          //if (debug)
+            System.out.println(&quot;worse, but moving.&quot;);
+        }
+      }
+    }
+
+    for (int p = 0; p &lt; dimPersons; p++)
+      for (int t = 0; t &lt; dimTopics; t++)
+        solution.setRole(p, t, bestAssignment[p][t]);
+
+    if (debug)
+    {
+      target = solution.calculateTargetValue();
+      System.out.println(this + &quot;target=&quot; + target + &quot;  bestTargetTotal=&quot;
+                         + bestTargetTotal);
+    }
+  }
+
+  /**
+   * Assign the roles to produce a solution.
+   * After calling this method, isValidSoution() should be used
+   * to check whether a valid solution has been reached.
+   */
+  void assignRoles()
+  {
+    int dimPersons     = persons.getNumber();
+    int dimTopics      = topics.getNumber();
+    int dimSessions    = getSessionNumber();
+    int dimRoles       = getRoles().getNumber();
+    int nAssignments   = dimPersons * dimTopics / dimSessions;
+    int unassignedRole = dimRoles + 1; // Marker for an unassigned role
+
+    for (int topic = 0;  topic &lt; dimTopics;  ++topic)
+      Arrays.fill(topicRole[topic], 0);
+
+    for (int person = 0;  person &lt; dimPersons;  ++person)
+      Arrays.fill(personRole[person], 0);
+
+    for (int as = 0;  as &lt; nAssignments + 1;  ++as)
+      Arrays.fill(seqPersons[as], 0);
+
+    int topicLimit  = dimPersons / dimSessions / dimRoles;
+    int personLimit = dimTopics / dimSessions / dimRoles;
+
+    // for every role we repeat the same procedure:
+    // we try to allocate the role according to the preference of the person
+    // we perform backtracking to find a valid solution
+    boolean debug = false;
+
+    if (debug)
+      System.out.println(this);
+
+    // we define the sequence in which we want to assign roles to the persons
+    // we change the sequence of persons for each step to prevent a bias
+		int noStep   = 0;
+		int maxSteps = 100000; // Integer.MAX_VALUE;
+		solved = true;
+		
+    for (int n = 0; n &lt; nAssignments; n++)
+    {
+      int p = n % dimPersons;
+      int cycle = n / dimPersons;
+      seqPersons[n][0] = (cycle % 2 == 0) ? p : dimPersons - 1 - p;
+    }
+
+    for (int n = 0; n &lt; nAssignments; n++)
+    {
+			if (++noStep &gt; maxSteps)
+			{
+			  solved = false;
+			  break;
+			}
+			
+      int r = (n / (nAssignments / dimRoles)) + 1;
+      int p = seqPersons[n][0];
+      boolean ok = false;
+      int t = 0, prio;
+      
+      for (prio = seqPersons[n][1]; prio &lt; dimTopics; prio++)
+      {
+        t = persons.getPreferenceIndex(p, prio);
+        
+        if (solution.getRole(p, t) == unassignedRole)
+        {
+          if (debug)
+            System.out.print(&quot;n=&quot; + n + &quot; r=&quot; + r + &quot; p=&quot; + p + &quot; t=&quot; + t);
+          
+          // try to assign the role
+          if (topicRole[t][r] &lt; topicLimit &amp;&amp; personRole[p][r] &lt; personLimit)
+          {
+            solution.setRole(p, t, r);
+            topicRole[t][r] += 1;
+            personRole[p][r] += 1;
+            
+            if (debug)
+              System.out.println(&quot;  assigned.&quot;);
+            
+            ok = true;
+            break;
+          }
+          else
+          {
+            ok = false;
+            
+            if (debug)
+              System.out.println(&quot;  not possible.&quot;);
+          }
+        }
+      }
+      
+      if (ok)
+      { // going forward, reset minPrio for next n
+        seqPersons[n][1] = prio + 1;
+        seqPersons[n + 1][1] = 0;
+      }
+      else
+      { // back tracking
+        n -= 1;
+
+        p = seqPersons[n][0];
+        t = persons.getPreferenceIndex(p, seqPersons[n][1] - 1);
+        solution.setRole(p, t, unassignedRole);
+        topicRole[t][r] -= 1;
+        personRole[p][r] -= 1;
+        n -= 1;
+      }
+    }
+    
+		// System.out.println (noStep + &quot; steps performed.&quot;);
+  }
+
+ 
+  /**
+   * Create a Solution object from the current solution.
+   * 
+   * @param index this is the current number of the solution.
+   *              Will be used to give the solution an initial name
+   *              (&quot;Solution &lt;index&gt;&quot;).
+   * @return the new Solution object.
+   */
+  public Solution createSolution(int index)
+  {
+    if (!solved)
+      return null;
+
+    solution.evaluate();
+    
+    StringBuffer name = new StringBuffer(&quot;Solution &quot; + (index+1));
+    name.append(&quot;: &quot;);
+    name.append(compactFormat.format(solution.getMeanDeviation()));
+    name.append(&quot; - &quot;);
+    name.append(compactFormat.format(solution.getMaximumDeviation()));
+    name.append(&quot; - &quot;);
+    name.append(compactFormat.format(solution.getStandardDeviation()));
+    solution.setName(name.toString());
+    
+    return solution;
+  }
+  
 }
\ No newline at end of file

Modified: trunk/openSess/SolverConstructor.java
===================================================================
--- trunk/openSess/SolverConstructor.java	2005-03-15 13:52:49 UTC (rev 17)
+++ trunk/openSess/SolverConstructor.java	2005-03-20 13:54:06 UTC (rev 18)
@@ -107,11 +107,13 @@
       currentSolution.setName(getString(attributes, &quot;name&quot;, solution));
       main.getSolver().addSolution(currentSolution);
     }
+/*
     else if (qName.equals(&quot;statistics&quot;))
       currentSolution.setStatistics(getDouble(attributes, &quot;meandev&quot;, 0.0),
                                     getDouble(attributes, &quot;maxdev&quot;,  0.0),
                                     getDouble(attributes, &quot;stddev&quot;,  0.0),
                                     getInt(attributes, &quot;target&quot;,     0));
+*/                                    
     else if (qName.equals(&quot;topicGroups&quot;))
       group = -1;
     else if (qName.equals(&quot;topicGroup&quot;))

Added: trunk/openSess/TaskMonitor.java
===================================================================
--- trunk/openSess/TaskMonitor.java	2005-03-15 13:52:49 UTC (rev 17)
+++ trunk/openSess/TaskMonitor.java	2005-03-20 13:54:06 UTC (rev 18)
@@ -0,0 +1,173 @@
+/*
+ * Copyright 2005 Andreas Wickner
+ * 
+ * Created:     2005-03-19 
+ * Revision ID: $Id$
+ * 
+ * This file is part of OpenSess.
+ * OpenSess is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public License as published by 
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ *
+ * OpenSess is distributed in the hope that it will be useful, but 
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along 
+ * with OpenSess; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
+ */
+package openSess;
+
+/**
+ * TaskMonitor is a base class for classes that must perform
+ * a task in a different (non-GUI) thread. The task progress can
+ * be visualized with a ProgressMonitor.
+ * 
+ * Classes that extend TaskMonitor should:
+ * 
+ * - Redefine doTask() to contain the work to be done in the
+ *   new thread.
+ * - Check taskWasCanceled() frequently to see whether the task
+ *   was canceled from the outside (e.g. by the GUI user). If this
+ *   is the case, doTask() should terminate as soon as possible.
+ * - Call setCurrent() whenever there is progress to report. The value
+ *   passed to setCurrent() should be appropriate for the ProgressMonitor.
+ * - Call setMessage() with progress messages if appropriate.
+ * 
+ * @author andreas
+ */
+public class TaskMonitor
+{
+  private int              current      = 0;
+  private boolean          taskDone     = false;
+  private boolean          taskCanceled = false;
+  private String           statMessage;
+  
+  /**
+   * Return the current progress.
+   * 
+   * @return the current progress.
+   */
+  public int getCurrent()
+  {
+    return current;
+  }
+
+  /**
+   * Set the current progress (must be in the valid range of the
+   * ProgressMonitor used).
+   *  
+   * @param current the current progress.
+   */
+  public void setCurrent(int current)
+  {
+    this.current = current;
+  }
+  
+  /**
+   * Can be used to cancel the task from the outside.
+   */
+  public void stop()
+  {
+    taskCanceled = true;
+    statMessage = null;
+  }
+
+  /**
+   * Returns whether the task was canceled from outside.
+   * 
+   * @return true if the task has been canceled.
+   */
+  public boolean taskWasCanceled()
+  {
+    return taskCanceled;
+  }
+
+  /**
+   * Returns whether the task has completed (by itself).
+   * 
+   * @return true if completed, false otherwise.
+   */
+  public boolean isDone()
+  {
+    return taskDone;
+  }
+
+  /**
+   * Returns the most recent status message, or null
+   * if there is no current status message.
+   * 
+   * @return a status message.
+   */
+  public String getMessage()
+  {
+    return statMessage;
+  }
+
+  /**
+   * Sets the current status message.
+   * 
+   * @param message
+   */
+  public void setMessage(String message)
+  {
+    statMessage = message;
+  }
+  
+  /**
+   * Start the task: Call the method doTask() in its own thread.
+   */
+  public void startTask()
+  {
+    final TaskMonitor theMonitorItself = this;
+    
+    final SwingWorker worker = new SwingWorker()
+    {
+      public Object construct()
+      {
+        current = 0;
+        taskDone = false;
+        taskCanceled = false;
+        statMessage = null;
+        return new SolverTask(theMonitorItself); 
+      }
+    };
+    
+    worker.start();
+  }
+
+  /**
+   * Derived classes should redefine this method with the work to
+   * be done.
+   */
+  protected void doTask()
+  {
+  }
+
+  /**
+   * SolverTask wraps the actual work to do in a way that is
+   * compatible with the SwingWorker.
+   * 
+   * @author andreas
+   */
+  private class SolverTask
+  {
+    /**
+     * The constructor contains the actual work to do
+     * (which is our solution calculation).
+     * 
+     * @param solver the Solver object.
+     * @param dimTryTopicClustering  the number of topic clusterings to try.
+     * @param dimTryPersonAssignment the number of topic/person assignments to try.
+     * @param dimTryAlloc            the maximum number of assignments to try.
+     */
+    public SolverTask(TaskMonitor monitor)
+    {
+      monitor.doTask();
+      monitor.taskDone = true;
+    }
+  };
+}

Modified: trunk/openSess/Topics.java
===================================================================
--- trunk/openSess/Topics.java	2005-03-15 13:52:49 UTC (rev 17)
+++ trunk/openSess/Topics.java	2005-03-20 13:54:06 UTC (rev 18)
@@ -11,7 +11,7 @@
  * Copyright 2005 Gero Scholz, Andreas Wickner
  * 
  * Created:     2005-02-11 
- * Revision ID: $Id$
+ * Revision ID: $Id: Topics.java 10 2005-03-04 18:45:41Z awickner $
  * 
  * This file is part of OpenSess.
  * OpenSess is free software; you can redistribute it and/or modify it 
@@ -43,23 +43,22 @@
   private int               rank[];
   private int               rankInx[];
   private int               dist[][];
-  private int               dimPersons;
 
   /**
    * Creates a new Topics object with configuration data from a Solver object.
    * 
    * @param solver  a Solver object.
    */
-  public Topics(Solver solver)
+  public Topics(Solver solver, int dimTopics)
   {
     // create topic list
     this.solver = solver;
     names = new DefaultListModel();
 
-    for (int t = 0; t &lt; solver.dimTopics; t++)
+    for (int t = 0; t &lt; dimTopics; t++)
       names.addElement(&quot;Topic &quot; + (t+1));
 
-    dist = new int[solver.dimTopics][solver.dimTopics];
+    dist = new int[dimTopics][dimTopics];
   }
 
   /**
@@ -111,30 +110,37 @@
   protected void calcPrefs()
   {
     boolean debug = false;
-    pref = new int[solver.dimTopics];
-    for (int t = 0; t &lt; solver.dimTopics; t++)
+    int dimTopics = getNumber();
+    int dimPersons = solver.getPersons().getNumber();
+    
+    pref = new int[dimTopics];
+    
+    for (int t = 0;  t &lt; dimTopics;  t++)
     {
       pref[t] = 0;
-      for (int p = 0; p &lt; solver.dimPersons; p++)
+      for (int p = 0; p &lt; dimPersons; p++)
       {
-        pref[t] += solver.getPersons().pref[p][t];
+        pref[t] += solver.getPersons().getPreference(p, t);
+        
         if (debug)
           System.out.println(&quot;Thema &quot; + getName(t) + &quot; pref+=&quot;
-                             + solver.getPersons().pref[p][t]);
+                             + solver.getPersons().getPreference(p, t));
       }
     }
 
     // calculate the total rank of each topic
     // so that we can show topics ordered by rank if desired
-    rank = new int[solver.dimTopics];
-    rankInx = new int[solver.dimTopics];
+    rank = new int[dimTopics];
+    rankInx = new int[dimTopics];
 
     int prefH[] = (int[]) pref.clone();
-    for (int t = 0; t &lt; solver.dimTopics; t++)
+    
+    for (int t = 0; t &lt; dimTopics; t++)
     {
       int min = Integer.MAX_VALUE;
       int tmin = 0;
-      for (int tt = 0; tt &lt; solver.dimTopics; tt++)
+      
+      for (int tt = 0; tt &lt; dimTopics; tt++)
       {
         if (prefH[tt] &lt; min)
         {
@@ -145,6 +151,7 @@
             System.out.println(&quot;rank &quot; + tt + &quot;, value &quot; + min);
         }
       }
+      
       rankInx[t] = tmin;
       prefH[tmin] = Integer.MAX_VALUE;
       if (debug)
@@ -162,9 +169,12 @@
    */
   protected void calcDist(Persons persons)
   {
-    for (int t = 0; t &lt; solver.dimTopics; t++)
+    int dimTopics = getNumber();
+    int dimPersons = solver.getPersons().getNumber();
+    
+    for (int t = 0;  t &lt; dimTopics;  t++)
     {
-      for (int tt = 0; tt &lt; solver.dimTopics; tt++)
+      for (int tt = 0;  tt &lt; dimTopics;  tt++)
       {
         if (t == tt)
           dist[t][tt] = 0;
@@ -173,9 +183,9 @@
         else
         {
           int sum = 0, dif;
-          for (int p = 0; p &lt; solver.dimPersons; p++)
+          for (int p = 0;  p &lt; dimPersons;  p++)
           {
-            dif = persons.pref[p][t] - persons.pref[p][tt];
+            dif = persons.getPreference(p, t) - persons.getPreference(p, tt);
             sum += dif * dif;
           }
           dist[tt][t] = dist[t][tt] = sum;
@@ -195,9 +205,10 @@
   protected int hashSum(int vec[])
   {
     int hashVal = 0;
+    int dimTopics = getNumber();
     
     for (int n = 0; n &lt; vec.length; n++)
-      hashVal += (n + 1) * (solver.dimTopics) * (vec[n] + 1) * (vec[n] + 1);
+      hashVal += (n + 1) * dimTopics * (vec[n] + 1) * (vec[n] + 1);
 
     return hashVal;
   }
@@ -239,7 +250,7 @@
     // 0,1,2, ..
 
     // we start with a simple initial grouping
-    int n = solver.dimTopics;
+    int n = getNumber();
     int vec[] = new int[n];
     int bestVec[] = new int[n];
     for (int i = 0; i &lt; n; i++)
@@ -363,21 +374,23 @@
    */
   protected void normalize(int vec[])
   {
+    int dimTopics = getNumber();
     int gr = 0;
-    for (int t = 0; t &lt; solver.dimTopics; t++)
+    
+    for (int t = 0; t &lt; dimTopics; t++)
     {
       if (vec[t] &gt;= 100)
         continue;
       int vOld = vec[t];
       vec[t] = 100 + gr;
-      for (int tt = t + 1; tt &lt; solver.dimTopics; tt++)
+      for (int tt = t + 1; tt &lt; dimTopics; tt++)
       {
         if (vec[tt] == vOld)
           vec[tt] = 100 + gr;
       }
       gr += 1;
     }
-    for (int t = 0; t &lt; solver.dimTopics; t++)
+    for (int t = 0; t &lt; dimTopics; t++)
       vec[t] -= 100;
   }
 
@@ -445,13 +458,14 @@
    */
   protected String distToString()
   {
+    int dimTopics = getNumber();
     String s = new String();
     String field;
     s += &quot;      &quot; + toHeaderString(&quot;    &quot;) + &quot;\n&quot;;
-    for (int t = 0; t &lt; solver.dimTopics; t++)
+    for (int t = 0; t &lt; dimTopics; t++)
     {
       s += &quot; &quot; + getName(t);
-      for (int tt = 0; tt &lt; solver.dimTopics; tt++)
+      for (int tt = 0; tt &lt; dimTopics; tt++)
       {
         field = &quot;     &quot; + dist[t][tt];
         s += field.substring(field.length() - 5);
@@ -469,9 +483,10 @@
    */
   public String toHeaderString(String space)
   {
+    int dimTopics = getNumber();
     StringBuffer s = new StringBuffer();
     
-    for (int t = 0; t &lt; solver.dimTopics; t++)
+    for (int t = 0; t &lt; dimTopics; t++)
       s.append(getName(t) + space);
     
     return s.toString();
@@ -486,10 +501,11 @@
    */
   public String groupsToString(int groups[], int groupsCount)
   {
+    int dimTopics = getNumber();
     String s = new String();
     for (int gr = 0; gr &lt; groupsCount; gr++)
     {
-      for (int t = 0; t &lt; solver.dimTopics; t++)
+      for (int t = 0; t &lt; dimTopics; t++)
       {
         if (groups[t] != gr)
           continue;
@@ -507,8 +523,12 @@
    */
   public String toString()
   {
+    int dimTopics = getNumber();
+    int dimPersons = solver.getPersons().getNumber();
+    
     String s = new String();
-    for (int t = 0; t &lt; solver.dimTopics; t++)
+    
+    for (int t = 0;  t &lt; dimTopics;  t++)
     {
       int tt = rankInx[t];
       s += &quot;      &quot; + getName(tt) + &quot; &quot; + (pref[tt] + dimPersons) + &quot;\n&quot;;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000012.html">[Opensess-svn] r17 - branches/alternative-assign/openSess
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13">[ date ]</a>
              <a href="thread.html#13">[ thread ]</a>
              <a href="subject.html#13">[ subject ]</a>
              <a href="author.html#13">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/opensess-svn">More information about the Opensess-svn
mailing list</a><br>
</body></html>
